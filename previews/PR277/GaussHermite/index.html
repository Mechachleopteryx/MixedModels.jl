<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Normalized Gauss-Hermite Quadrature · MixedModels</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="MixedModels logo"/></a><div class="docs-package-name"><span class="docs-autofit">MixedModels</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">MixedModels.jl Documentation</a></li><li><a class="tocitem" href="../constructors/">Model constructors</a></li><li><a class="tocitem" href="../optimization/">Details of the parameter estimation</a></li><li class="is-active"><a class="tocitem" href>Normalized Gauss-Hermite Quadrature</a><ul class="internal"><li><a class="tocitem" href="#Evaluating-the-weights-and-abscissae-1"><span>Evaluating the weights and abscissae</span></a></li><li><a class="tocitem" href="#Application-to-a-model-for-contraception-use-1"><span>Application to a model for contraception use</span></a></li></ul></li><li><a class="tocitem" href="../bootstrap/">Parametric bootstrap for linear mixed-effects models</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Normalized Gauss-Hermite Quadrature</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Normalized Gauss-Hermite Quadrature</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaStats/MixedModels.jl/blob/master/docs/src/GaussHermite.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Normalized-Gauss-Hermite-Quadrature-1"><a class="docs-heading-anchor" href="#Normalized-Gauss-Hermite-Quadrature-1">Normalized Gauss-Hermite Quadrature</a><a class="docs-heading-anchor-permalink" href="#Normalized-Gauss-Hermite-Quadrature-1" title="Permalink"></a></h1><p><a href="https://en.wikipedia.org/wiki/Gaussian_quadrature"><em>Gaussian Quadrature rules</em></a> provide sets of <code>x</code> values, called <em>abscissae</em>, and weights, <code>w</code>, to approximate an integral with respect to a <em>weight function</em>, <span>$g(x)$</span>. For a <code>k</code>th order rule the approximation is</p><div>\[\int f(x)g(x)\,dx \approx \sum_{i=1}^k w_i f(x_i)\]</div><p>For the <em>Gauss-Hermite</em> rule the weight function is</p><div>\[g(x) = e^{-x^2}\]</div><p>and the domain of integration is <span>$(-\infty, \infty)$</span>. A slight variation of this is the <em>normalized Gauss-Hermite</em> rule for which the weight function is the standard normal density</p><div>\[g(z) = \phi(z) = \frac{e^{-z^2/2}}{\sqrt{2\pi}}\]</div><p>Thus, the expected value of <span>$f(z)$</span>, where <span>$\mathcal{Z}\sim\mathscr{N}(0,1)$</span>, is approximated as</p><div>\[\mathbb{E}[f]=\int_{-\infty}^{\infty} f(z) \phi(z)\,dz\approx\sum_{i=1}^k w_i\,f(z_i) .\]</div><p>Naturally, there is a caveat. For the approximation to be accurate the function <span>$f(z)$</span> must behave like a low-order polynomial over the range of interest. More formally, a <code>k</code>th order rule is exact when <code>f</code> is a <code>k-1</code> order polynomial.</p><h2 id="Evaluating-the-weights-and-abscissae-1"><a class="docs-heading-anchor" href="#Evaluating-the-weights-and-abscissae-1">Evaluating the weights and abscissae</a><a class="docs-heading-anchor-permalink" href="#Evaluating-the-weights-and-abscissae-1" title="Permalink"></a></h2><p>In the <a href="https://en.wikipedia.org/wiki/Gaussian_quadrature#The_Golub-Welsch_algorithm"><em>Golub-Welsch algorithm</em></a> the abscissae for a particular Gaussian quadrature rule are determined as the eigenvalues of a symmetric tri-diagonal matrix and the weights are derived from the squares of the first row of the matrix of eigenvectors. For a <code>k</code>th order normalized Gauss-Hermite rule the tridiagonal matrix has zeros on the diagonal and the square roots of <code>1:k-1</code> on the super- and sub-diagonal, e.g.</p><pre><code class="language-julia">julia&gt; using DataFrames, LinearAlgebra, Gadfly

julia&gt; sym3 = SymTridiagonal(zeros(3), sqrt.(1:2))
3×3 LinearAlgebra.SymTridiagonal{Float64,Array{Float64,1}}:
 0.0  1.0       ⋅     
 1.0  0.0      1.41421
  ⋅   1.41421  0.0    

julia&gt; ev = eigen(sym3);

julia&gt; show(ev.values)
[-1.7320508075688739, 1.1102230246251565e-15, 1.7320508075688774]
julia&gt; show(abs2.(ev.vectors[1,:]))
[0.16666666666666743, 0.6666666666666657, 0.16666666666666677]</code></pre><p>As a function of <code>k</code> this can be written as</p><pre><code class="language-julia">function gausshermitenorm(k)
    ev = eigen(SymTridiagonal(zeros(k), sqrt.(1:k-1)))
    ev.values, abs2.(ev.vectors[1,:])
end</code></pre><p>providing</p><pre><code class="language-julia">julia&gt; gausshermitenorm(3)
([-1.7320508075688739, 1.1102230246251565e-15, 1.7320508075688774], [0.16666666666666743, 0.6666666666666657, 0.16666666666666677])
</code></pre><p>The weights and positions are often shown as a <em>lollipop plot</em>. For the 9th order rule these are <img src="../docs/assets/GaussHermite_4_1.svg" alt="Lollipop plot of 9th order normalized Gauss-Hermite rule"/></p><p>Notice that the magnitudes of the weights drop quite dramatically away from zero, even on a logarithmic scale <img src="../docs/assets/GaussHermite_5_1.svg" alt="Lollipop plot of 9th order normalized Gauss-Hermite rule (logarithmic scale"/></p><p>The definition of <code>MixedModels.GHnorm</code> is similar to the <code>gausshermitenorm</code> function with some extra provisions for ensuring symmetry of the abscissae and the weights and for caching values once they have been calculated.</p><article class="docstring"><header><a class="docstring-binding" id="MixedModels.GHnorm" href="#MixedModels.GHnorm"><code>MixedModels.GHnorm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">GHnorm(k::Int)</code></pre><p>Return the (unique) GaussHermiteNormalized{k} object.</p><p>The function values are stored (memoized) when first evaluated.  Subsequent evaluations for the same <code>k</code> have very low overhead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/MixedModels.jl/blob/4214867b90371941c0b352dc793a18015ac13bfb/src/gausshermite.jl#L72-L79">source</a></section></article><pre><code class="language-julia">julia&gt; using MixedModels

julia&gt; GHnorm(3)
MixedModels.GaussHermiteNormalized{3}([-1.7320508075688772, 0.0, 1.7320508075688772], [0.16666666666666666, 0.6666666666666666, 0.16666666666666666])
</code></pre><p>By the properties of the normal distribution, when <span>$\mathcal{X}\sim\mathscr{N}(\mu, \sigma^2)$</span></p><div>\[\mathbb{E}[g(x)] \approx \sum_{i=1}^k g(\mu + \sigma z_i)\,w_i\]</div><p>For example, <span>$\mathbb{E}[\mathcal{X}^2]$</span> where <span>$\mathcal{X}\sim\mathcal{N}(2, 3^2)$</span> is</p><pre><code class="language-julia">julia&gt; μ = 2; σ = 3; ghn3 = GHnorm(3);

julia&gt; sum(@. ghn3.w * abs2(μ + σ * ghn3.z))  # should be μ² + σ² = 13
13.0
</code></pre><p>(In general a dot, &#39;<code>.</code>&#39;, after the function name in a function call, as in <code>abs2.(...)</code>, or before an operator creates a <a href="https://docs.julialang.org/en/stable/manual/performance-tips/#More-dots:-Fuse-vectorized-operations-1"><em>fused vectorized</em></a> evaluation in Julia. The macro <code>@.</code> has the effect of vectorizing all operations in the subsequent expression.)</p><h2 id="Application-to-a-model-for-contraception-use-1"><a class="docs-heading-anchor" href="#Application-to-a-model-for-contraception-use-1">Application to a model for contraception use</a><a class="docs-heading-anchor-permalink" href="#Application-to-a-model-for-contraception-use-1" title="Permalink"></a></h2><p>A <em>binary response</em> is a &quot;Yes&quot;/&quot;No&quot; type of answer. For example, in a 1989 fertility survey of women in Bangladesh (reported in <a href="https://www.popline.org/node/371841">Huq, N. M. and Cleland, J., 1990</a>) one response of interest was whether the woman used artificial contraception. Several covariates were recorded including the woman&#39;s age (centered at the mean), the number of live children the woman has had (in 4 categories: 0, 1, 2, and 3 or more), whether she lived in an urban setting, and the district in which she lived. The version of the data used here is that used in review of multilevel modeling software conducted by the Center for Multilevel Modelling, currently at University of Bristol (http://www.bristol.ac.uk/cmm/learning/mmsoftware/data-rev.html). These data are available as the <code>Contraception</code> data frame in the test data for the <code>MixedModels</code> package.</p><pre><code class="language-julia">julia&gt; contra = MixedModels.dataset(:contra)
1934×6 DataFrames.DataFrame
│ Row  │ dist   │ urban  │ urbdist │ livch  │ age     │ use    │
│      │ String │ String │ String  │ String │ Float32 │ String │
├──────┼────────┼────────┼─────────┼────────┼─────────┼────────┤
│ 1    │ D01    │ Y      │ U01     │ 3+     │ 18.44   │ N      │
│ 2    │ D01    │ Y      │ U01     │ 0      │ -5.56   │ N      │
│ 3    │ D01    │ Y      │ U01     │ 2      │ 1.44    │ N      │
│ 4    │ D01    │ Y      │ U01     │ 3+     │ 8.44    │ N      │
│ 5    │ D01    │ Y      │ U01     │ 0      │ -13.56  │ N      │
│ 6    │ D01    │ Y      │ U01     │ 0      │ -11.56  │ N      │
│ 7    │ D01    │ Y      │ U01     │ 3+     │ 18.44   │ N      │
⋮
│ 1927 │ D61    │ N      │ R61     │ 3+     │ 19.44   │ N      │
│ 1928 │ D61    │ N      │ R61     │ 2      │ -9.56   │ Y      │
│ 1929 │ D61    │ N      │ R61     │ 2      │ -2.56   │ N      │
│ 1930 │ D61    │ N      │ R61     │ 3+     │ 14.44   │ N      │
│ 1931 │ D61    │ N      │ R61     │ 2      │ -4.56   │ N      │
│ 1932 │ D61    │ N      │ R61     │ 3+     │ 14.44   │ N      │
│ 1933 │ D61    │ N      │ R61     │ 0      │ -13.56  │ N      │
│ 1934 │ D61    │ N      │ R61     │ 3+     │ 10.44   │ N      │

julia&gt; describe(contra)
6×8 DataFrames.DataFrame. Omitted printing of 1 columns
│ Row │ variable │ mean       │ min    │ median │ max   │ nunique │ nmissing │
│     │ Symbol   │ Union…     │ Any    │ Union… │ Any   │ Union…  │ Nothing  │
├─────┼──────────┼────────────┼────────┼────────┼───────┼─────────┼──────────┤
│ 1   │ dist     │            │ D01    │        │ D61   │ 60      │          │
│ 2   │ urban    │            │ N      │        │ Y     │ 2       │          │
│ 3   │ urbdist  │            │ R01    │        │ U61   │ 102     │          │
│ 4   │ livch    │            │ 0      │        │ 3+    │ 4       │          │
│ 5   │ age      │ 0.00204738 │ -13.56 │ -1.56  │ 19.44 │         │          │
│ 6   │ use      │            │ N      │        │ Y     │ 2       │          │
</code></pre><p>A smoothed scatterplot of contraception use versus age <img src="../docs/assets/GaussHermite_9_1.svg" alt="Scatterplot smooth of contraception use versus age"/></p><p>shows that the proportion of women using artificial contraception is approximately quadratic in age.</p><p>A model with fixed-effects for age, age squared, number of live children and urban location and with random effects for district, is fit as</p><pre><code class="language-julia">julia&gt; const form1 = @formula use ~ 1 + age + abs2(age) + livch + urban + (1|dist);

julia&gt; m1 = fit!(GeneralizedLinearMixedModel(form1, contra,
    Bernoulli()), fast=true)
Generalized Linear Mixed Model fit by maximum likelihood (nAGQ = 1)
  use ~ 1 + age + :(abs2(age)) + livch + urban + (1 | dist)
  Distribution: Bernoulli{Float64}
  Link: LogitLink()

  Deviance: 2372.7843

Variance components:
        Column    Variance   Std.Dev.  
dist (Intercept)  0.21774806 0.46663483

 Number of obs: 1934; levels of grouping factors: 60

Fixed-effects parameters:
───────────────────────────────────────────────────────
                Estimate    Std.Error  z value  P(&gt;|z|)
───────────────────────────────────────────────────────
(Intercept)  -1.01528     0.17102        -5.94   &lt;1e-8 
age           0.00351074  0.00905384      0.39   0.6982
abs2(age)    -0.0044865   0.000710531    -6.31   &lt;1e-9 
livch: 1      0.801876    0.15912         5.04   &lt;1e-6 
livch: 2      0.901014    0.181636        4.96   &lt;1e-6 
livch: 3+     0.899415    0.182254        4.93   &lt;1e-6 
urban: Y      0.684404    0.117653        5.82   &lt;1e-8 
───────────────────────────────────────────────────────
</code></pre><p>For a model such as <code>m1</code>, which has a single, scalar random-effects term, the unscaled conditional density of the spherical random effects variable, <span>$\mathcal{U}$</span>, given the observed data, <span>$\mathcal{Y}=\mathbf{y}_0$</span>, can be expressed as a product of scalar density functions, <span>$f_i(u_i),\; i=1,\dots,q$</span>. In the PIRLS algorithm, which determines the conditional mode vector, <span>$\tilde{\mathbf{u}}$</span>, the optimization is performed on the <em>deviance scale</em>,</p><div>\[D(\mathbf{u})=-2\sum_{i=1}^q \log(f_i(u_i))\]</div><p>The objective, <span>$D$</span>, consists of two parts: the sum of the (squared) <em>deviance residuals</em>, measuring fidelity to the data, and the squared length of <span>$\mathbf{u}$</span>, which is the penalty. In the PIRLS algorithm, only the sum of these components is needed. To use Gauss-Hermite quadrature the contributions of each of the <span>$u_i,\;i=1,\dots,q$</span> should be separately evaluated.</p><pre><code class="language-julia">julia&gt; const devc0 = map!(abs2, m1.devc0, m1.u[1]);  # start with uᵢ²

julia&gt; const devresid = m1.resp.devresid;   # n-dimensional vector of deviance residuals

julia&gt; const refs = first(m1.LMM.reterms).refs;  # n-dimensional vector of indices in 1:q

julia&gt; for (dr, i) in zip(devresid, refs)
    devc0[i] += dr
end

julia&gt; show(devc0)
[121.29247996885765, 22.02257343193451, 2.918900456614114, 30.787717826496092, 47.5420494061397, 69.55502474178111, 23.404687144597606, 46.27907407148361, 24.452780930924483, 7.759490635248255, 9.77366231603886, 42.75903562671126, 27.552494305012694, 156.42045116835772, 26.192468262933545, 27.416249202757175, 24.538089083056448, 57.566154338395165, 31.179403726097657, 22.341558780577653, 27.478094943605214, 19.988456487624678, 16.01085481011471, 9.761479051295831, 83.86349396675556, 15.568769342547753, 42.75968284306824, 51.46851359887511, 32.73334450559587, 70.4157242302106, 39.68586980664088, 27.544104011254753, 14.697567291857316, 53.04735392050496, 64.84964721227523, 19.743880656616437, 19.41551624204891, 11.24228541090821, 37.416774960259644, 54.265080842482234, 39.582495125284844, 17.398404780612502, 60.227812506873455, 28.819186016884895, 42.44425501631105, 112.99129218607499, 17.29770202025442, 51.57734302605573, 2.187213801051859, 22.96155928643509, 47.414475698670365, 87.2316235420713, 25.923443843049636, 9.470291290127507, 61.17586281457857, 27.10281831025878, 48.01617439986505, 8.460202624829035, 30.365222094816037, 47.37415976127611]</code></pre><p>One thing to notice is that, even on the deviance scale, the contributions of different districts can be of different magnitudes. This is primarily due to different sample sizes in the different districts.</p><pre><code class="language-julia">julia&gt; using FreqTables

julia&gt; freqtable(contra, :dist)&#39;
1×60 Named LinearAlgebra.Adjoint{Int64,Array{Int64,1}}
&#39; ╲ dist │ D01  D02  D03  D04  D05  D06  …  D56  D57  D58  D59  D60  D61
─────────┼──────────────────────────────────────────────────────────────
1        │ 117   20    2   30   39   65  …   45   27   33   10   32   42
</code></pre><p>Because the first district has one of the largest sample sizes and the third district has the smallest sample size, these two will be used for illustration. For a range of <span>$u$</span> values, evaluate the individual components of the deviance and store them in a matrix.</p><pre><code class="language-julia">const devc = m1.devc;
const xvals = -5.0:2.0^(-4):5.0;
const uv = vec(m1.u[1]);
const u₀ = vec(m1.u₀[1]);
results = zeros(length(devc0), length(xvals))
for (j, u) in enumerate(xvals)
    fill!(devc, abs2(u))
    fill!(uv, u)
    MixedModels.updateη!(m1)
    for (dr, i) in zip(devresid, refs)
        devc[i] += dr
    end
    copyto!(view(results, :, j), devc)
end</code></pre><p>A plot of the deviance contribution versus <span>$u_1$</span> <img src="../docs/assets/GaussHermite_14_1.svg" alt="Deviance contribution of u₁"/></p><p>shows that the deviance contribution is very close to a quadratic. This is also true for <span>$u_3$</span> <img src="../docs/assets/GaussHermite_15_1.svg" alt="Deviance contribution of u₃"/></p><p>The PIRLS algorithm provides the locations of the minima of these scalar functions, stored as</p><pre><code class="language-julia">julia&gt; m1.u₀[1]
1×60 Array{Float64,2}:
 -1.58477  -0.0727267  0.449058  0.341589  …  -0.767069  -0.902922  -1.06625
</code></pre><p>the minima themselves, evaluated as <code>devc0</code> above, and a horizontal scale, which is the inverse of diagonal of the Cholesky factor. As shown below, this is an estimate of the conditional standard deviations of the components of <span>$\mathcal{U}$</span>.</p><pre><code class="language-julia">julia&gt; const s = inv.(m1.LMM.L[Block(1,1)].diag);

julia&gt; s&#39;
1×60 LinearAlgebra.Adjoint{Float64,Array{Float64,1}}:
 0.406888  0.713511  0.952164  0.627134  …  0.839678  0.654964  0.603258
</code></pre><p>The curves can be put on a common scale, corresponding to the standard normal, as</p><pre><code class="language-julia">julia&gt; for (j, z) in enumerate(xvals)
    @. uv = u₀ + z * s
    MixedModels.updateη!(m1)
    @. devc = abs2(uv) - devc0
    for (dr, i) in zip(devresid, refs)
        devc[i] += dr
    end
    copyto!(view(results, :, j), devc)
end
</code></pre><p><img src="../docs/assets/GaussHermite_19_1.svg" alt="Scaled and shifted deviance contributions"/></p><p><img src="../docs/assets/GaussHermite_20_1.svg" alt="Scaled and shifted deviance contributions"/></p><p>On the original density scale these become</p><pre><code class="language-julia">julia&gt; for (j, z) in enumerate(xvals)
    @. uv = u₀ + z * s
    MixedModels.updateη!(m1)
    @. devc = abs2(uv) - devc0
    for (dr, i) in zip(devresid, refs)
        devc[i] += dr
    end
    copyto!(view(results, :, j), @. exp(-devc/2))
end
</code></pre><p><img src="../docs/assets/GaussHermite_22_1.svg" alt="Scaled and shifted conditional density"/></p><p><img src="../docs/assets/GaussHermite_23_1.svg" alt="Scaled and shifted conditional density"/></p><p>and the function to be integrated with the normalized Gauss-Hermite rule is</p><pre><code class="language-julia">julia&gt; for (j, z) in enumerate(xvals)
    @. uv = u₀ + z * s
    MixedModels.updateη!(m1)
    @. devc = abs2(uv) - devc0
    for (dr, i) in zip(devresid, refs)
        devc[i] += dr
    end
    copyto!(view(results, :, j), @. exp((abs2(z) - devc)/2))
end
</code></pre><p><img src="../docs/assets/GaussHermite_25_1.svg" alt="Function to be integrated with normalized Gauss-Hermite rule"/></p><p><img src="../docs/assets/GaussHermite_26_1.svg" alt="Function to be integrated with normalized Gauss-Hermite rule"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../optimization/">« Details of the parameter estimation</a><a class="docs-footer-nextpage" href="../bootstrap/">Parametric bootstrap for linear mixed-effects models »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 20 February 2020 10:28">Thursday 20 February 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
